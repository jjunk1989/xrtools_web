<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset='utf-8'>
    <meta name='viewport' content='width=device-width, initial-scale=1, user-scalable=no'>
    <meta name='mobile-web-app-capable' content='yes'>
    <meta name='apple-mobile-web-app-capable' content='yes'>
    <title>WebXR 视频播放器</title>
    <link rel="stylesheet" href="css/common.css">
    <style>
        .title {
            color: #000;
            font-size: 16px;
            font-weight: 600;
            text-decoration: none; 
        }
    </style>
    <script src="https://unpkg.com/vconsole@latest/dist/vconsole.min.js"></script>
</head>

<body>
    <header class="container">
        <div class="info"></div>
        <div class="row">
            <h1>360 Videos</h1>
        </div>
        <div>
            <!-- 添加两个checkbox -->
            <input type="checkbox" id="angleCheckbox" checked="true" /> <label for=""> 180° 空间视频</label>
            <!-- <input type="checkbox" id="layoutCheckbox" checked="true" /> <label for=""> 设置为左右布局</label> -->
        </div>
        <div id="video-list">
        </div>
        <div id="container" style="position: absolute; left: -9999px; top: -9999px;"></div>
      </header>
      <main style='text-align: center;'>
      </main>


      <script type="importmap">
            {
                "imports": {
                    "three": "./js/three.module.js"
                }
            }
      </script>

    <script type="module">
        import * as THREE from 'three';

        (function () {
            'use strict';
            
            var vConsole = new window.VConsole();

            // XR globals.
            let xrSession = null;
            let xrRefSpace = null;
            let xrMediaFactory = null;
            let layer = null;
            let cylinder_layer = false;
            let list = [];
            let currentPlayIndex = 0;
            let videoLoaded = false;
            let pictureLoaded = false;
            let pictureTexture = null;
            // three render
            let camera = null;
            let scene = null;
            let renderer = null;
            let materialLeft = null;
            let materialRight = null;
            let meshLeft = null;
            let meshRight = null;

            let video = document.createElement('video');
            video.loop = false;
            video.crossOrigin = "anonymous";
            video.preload = 'auto';
            video.autoload = true;

            let lastGamepadMap = new Map();


            function deepCopyButtons(arr) {
                let res = [];
                for (let i = 0; i < arr.length; i++) {
                    res.push({
                        pressed: arr[i].pressed,
                        touched: arr[i].touched,
                        value: arr[i].value
                    });
                }
                return res;
            }

            function buttonReleaseThisFrame(source, gamepad, index) {
                if (!lastGamepadMap.has(source)) {
                    console.log(gamepad.buttons, source);
                    lastGamepadMap.set(source, deepCopyButtons(gamepad.buttons));
                    return false;
                }

                let lastGamepad = lastGamepadMap.get(source);

                let res = buttonPressedThisFrame(lastGamepad, index) && !buttonPressedThisFrame(gamepad.buttons, index);
                lastGamepad = deepCopyButtons(gamepad.buttons);
                lastGamepadMap.set(source, lastGamepad);

                return res;
            }

            function buttonPressedThisFrame(gamepad, index) {
                return (index < gamepad.length &&
                    gamepad[index].pressed);
            }

            video.onloadeddata = (event) => {
                showInfo('Video loaded data.');
                console.log("video onloadeddata");
                videoLoaded = true;
            }

            video.onplay = (event) => {
                showInfo('Video onplay.');
                console.log("video onplay");
                videoLoaded = true;           
            }

            video.oncanplaythrough = (event) => {
                showInfo('Video loaded successfully.');
                videoLoaded = true;   
                console.log("video oncanplaythrough");
            }

            video.onerror = (event) => {
                console.error('Error loading video:', event);
                showInfo('Error loading video.');
                // videoLoaded = false;
            };

            // 显示info
            function showInfo(msg) {
                var info = document.querySelector(".info");
                info.textContent = msg;
                info.style.display = "block";
                setTimeout(function() {
                    info.style.display = "none";
                }, 3000);
            }

            function playVideo(src) {
                videoLoaded = false;
                video.src = src;
                onButtonClicked();
            }

            function playPicture(src) {
                new THREE.TextureLoader().load(src, function(texture) {
                    pictureLoaded = true;
                    pictureTexture = texture;
                    onButtonClicked();
                });
            }

            // 获取视频文件列表并设置到 select 组件中
            fetch('/api/videos')
                .then(response => response.json())
                .then(data => {
                    if (data.code === 200) {
                        const videoList = document.getElementById('video-list');
                        let listHtml = '';
                        data.list.forEach((videoFile, index) => {
                            if (videoFile == "videos/info.txt") {
                                return;
                            }

                            let isPicture = false;
                            if (videoFile.indexOf("jpg") > -1 
                                || videoFile.indexOf("png") > -1
                                || videoFile.indexOf("jpeg") > -1
                                || videoFile.indexOf("xbm") > -1
                                || videoFile.indexOf("tif") > -1
                                || videoFile.indexOf("pjp") > -1
                                || videoFile.indexOf("svgz") > -1
                                || videoFile.indexOf("ico") > -1
                                || videoFile.indexOf("tiff") > -1
                                || videoFile.indexOf("gif") > -1
                                || videoFile.indexOf("svg") > -1
                                || videoFile.indexOf("jfif") > -1
                                || videoFile.indexOf("webp") > -1
                                || videoFile.indexOf("bmp") > -1
                                || videoFile.indexOf("pjpeg") > -1
                                || videoFile.indexOf("avif") > -1
                            ) {
                                isPicture = true;
                            }

                            listHtml += `
                                <div class="row">
                                    <div>
                                        <p class="title">${videoFile}</p>
                                        <!-- <video src="${videoFile}" controls="controls" width="500" height="auto"></video> -->
                                    </div>
                                    <button type="button" class="btn-enterxr" data-src="${videoFile}" data-isPicture="${isPicture}" data-index="${index}">EnterXR</button>
                                </div>
                            `;
                            list.push({
                                file: videoFile,
                                isPicture: isPicture,
                            });
                        });
                        videoList.innerHTML = listHtml;
                        let buttons = document.getElementsByClassName("btn-enterxr");
                        
                        for(let i = 0; i < buttons.length; i++) {
                            buttons[i].addEventListener("click", function(e) {
                                let src = e.target.getAttribute("data-src");
                                let isPicture = e.target.getAttribute("data-isPicture");
                                if (isPicture == "true") {
                                    // 直接打开图片
                                    playPicture(src);
                                } else {
                                    playVideo(src);
                                }
                            });
                        }
                    } else {
                        console.error('Error fetching video list:', data.message);
                    }
                })
                .catch(error => {
                    console.error('Error fetching video list:', error);
                });

            // Checks to see if WebXR is available and, if so, requests an XRDevice
            // that is connected to the system and tests it to ensure it supports the
            // desired session options.
            function initXR() {
                // Is WebXR available on this UA?
                if (navigator.xr) {
                    // If the device allows creation of exclusive sessions set it as the
                    // target of the 'Enter XR' button.
                    navigator.xr.isSessionSupported('immersive-vr').then((supported) => {
                        if (supported) {
                            // Updates the button to start an XR session when clicked.
                            showInfo('Support XR.');
                        } else {
                            showInfo('Not support XR.');
                        }
                    });
                }
            }

            // Called when the user clicks the button to enter XR. If we don't have a
            // session we'll request one, and if we do have a session we'll end it.
            function onButtonClicked() {
                if (!xrSession) {
                    //video.onplay = (event) => {
                        showInfo('Video loaded successfully.');
                        navigator.xr.requestSession('immersive-vr', { requiredFeatures: [
                        ], optionalFeatures: [
                            'layers',
                            'local-floor',
                            'bounded-floor',
                        ]}).then(onSessionStarted);
                    //}
                    video.play();
                } else {
                    xrSession.end();
                }
            }

            // Called when we've successfully acquired a XRSession. In response we
            // will set up the necessary session state and kick off the frame loop.
            function onSessionStarted(session) {
                showInfo('Entering XR...');

                xrSession = session;

                session.addEventListener('selectend', () => {
                    console.log('selectend');
                    nextVideo();
                });

                session.addEventListener('squeezeend', () => {
                    console.log("squeezeend");
                });

                // Listen for the sessions 'end' event so we can respond if the user
                // or UA ends the session for any reason.
                session.addEventListener('end', onSessionEnded);

                initRender(xrSession);

                showInfo('XR session started.');
            }

            // Called either when the user has explicitly ended the session by calling
            // session.end() or when the UA has ended the session for any reason.
            // At this point the session object is no longer usable and should be
            // discarded.
            function onSessionEnded(event) {
                xrSession = null;
                layer = null;
                meshLeft = null; 
                meshRight = null;
                video.pause();
                videoLoaded = false;
                pictureLoaded = false;
            }

            async function initRender(session) {

                const container = document.getElementById( 'container' );

                camera = new THREE.PerspectiveCamera( 70, window.innerWidth / window.innerHeight, 1, 2000 );
                camera.layers.enable( 1 ); // render left view when no stereo available

                //
                scene = new THREE.Scene();
                scene.background = new THREE.Color( 0x000000 );

                if (false) {
                    // left

                    const geometry1 = new THREE.BoxGeometry( 1, 1, 1 ); 

                    const uvs1 = geometry1.attributes.uv.array;

                    for ( let i = 0; i < uvs1.length; i += 2 ) {

                        uvs1[ i ] *= 0.5;

                    }

                    const material1 = new THREE.MeshBasicMaterial( {color: 0x00ff00} ); 
                    const cube1 = new THREE.Mesh( geometry1, material1 ); 

                    cube1.rotation.y = - Math.PI / 2;
                    cube1.position.z = -3;
                    cube1.layers.set( 1 ); // display in left eye only
                    scene.add( cube1 );

                    // right

                    const geometry2 = new THREE.BoxGeometry( 1, 1, 1 ); 

                    const uvs2 = geometry2.attributes.uv.array;

                    for ( let i = 0; i < uvs2.length; i += 2 ) {

                        uvs2[ i ] *= 0.5;
                        uvs2[ i ] += 0.5;

                    }

                    const material2 = new THREE.MeshBasicMaterial( {color: 0x00ff00} ); 

                    const cube2= new THREE.Mesh( geometry2, material2 );
                    cube2.position.z = -3;
                    cube2.rotation.y = - Math.PI / 2;
                    cube2.layers.set( 2 ); // display in right eye only
                    scene.add( cube2 );
                }

                renderer = new THREE.WebGLRenderer();
                renderer.setPixelRatio( window.devicePixelRatio );
                renderer.setSize( window.innerWidth, window.innerHeight );
                renderer.setAnimationLoop( animate );
                renderer.xr.enabled = true;
                renderer.xr.setReferenceSpaceType( 'local' );

                await renderer.xr.setSession( session );

                container.appendChild( renderer.domElement );

                //

                window.addEventListener( 'resize', () => {
                    setTimeout(() => {
                        onWindowResize();
                    }, 2000);
                });

            }

            function onWindowResize() {

                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();

                renderer.setSize( window.innerWidth, window.innerHeight );

            }

            function animate() {

                if((pictureLoaded || videoLoaded) && meshLeft == null && meshRight == null) {
                    const angleCheckbox = document.getElementById('angleCheckbox');
                    const is180 = angleCheckbox.checked;

                    const phiStart = is180 ? Math.PI / 2 : 0;
                    const phiLength = is180 ? Math.PI : Math.PI * 2;
                    const thetaStart = 0;
                    const thetaLength = Math.PI;

                    let texture = null;
                    if (pictureLoaded || pictureTexture != null) {
                        texture = pictureTexture;
                    } else {
                        texture = new THREE.VideoTexture( video );
                        texture.colorSpace = THREE.SRGBColorSpace;
                    }

                    // left

                    const geometry1 = new THREE.SphereGeometry( 500, 60, 40, phiStart, phiLength, thetaStart, thetaLength );
                    // invert the geometry on the x-axis so that all of the faces point inward
                    geometry1.scale( - 1, 1, 1 );
                    
                    const uvs1 = geometry1.attributes.uv.array;

                    for ( let i = 0; i < uvs1.length; i += 2 ) {

                        uvs1[ i ] *= 0.5;

                    }

                    console.log(geometry1);

                    materialLeft = new THREE.MeshBasicMaterial( { map: texture } );

                    meshLeft = new THREE.Mesh( geometry1, materialLeft );
                    meshLeft.rotation.y = - Math.PI / 2;
                    meshLeft.layers.set( 1 ); // display in left eye only
                    scene.add( meshLeft );

                    // right

                    const geometry2 = new THREE.SphereGeometry( 500, 60, 40, phiStart, phiLength, thetaStart, thetaLength );
                    geometry2.scale( - 1, 1, 1 );
                    geometry2.parameters.phiLength = Math.PI / 2;

                    const uvs2 = geometry2.attributes.uv.array;

                    for ( let i = 0; i < uvs2.length; i += 2 ) {

                        uvs2[ i ] *= 0.5;
                        uvs2[ i ] += 0.5;

                    }

                    materialRight = new THREE.MeshBasicMaterial( { map: texture } );

                    meshRight = new THREE.Mesh( geometry2, materialRight );
                    meshRight.rotation.y = - Math.PI / 2;
                    meshRight.layers.set( 2 ); // display in right eye only
                    scene.add( meshRight );
                }

                renderer.render( scene, camera );

                // if (xrSession.inputSources && xrSession.inputSources.length > 0) {
                //     for (let source of xrSession.inputSources) {
                //         if (source.hand) {
                //             // console.warn("hand");
                //             if (source.gamepad && source.gamepad.buttons[0]) {
                //                 nextVideo();
                //             }
                //         } else if (source.gamepad) {
                //             // Toggle Play/Pause on primary button press
                //             if (buttonReleaseThisFrame(source, source.gamepad, 0)) {
                //                 nextVideo();
                //             }
                //         }
                //     }
                // }
            }

            function nextVideo() {
                currentPlayIndex = (currentPlayIndex + 1) % list.length; 
                console.log("play next video: ", list[currentPlayIndex], currentPlayIndex);
                let source = list[currentPlayIndex];
                if (source.isPicture) {
                    new THREE.TextureLoader().load(source.file, function(texture) {
                        pictureLoaded = true;
                        pictureTexture = texture;
                    });
                    if (scene) {
                        scene.remove(meshLeft);
                        scene.remove(meshRight);
                        meshLeft = null;
                        meshRight = null;
                    }
                    videoLoaded = false;
                    pictureLoaded = false;
                } else {
                    video.src = source.file;
                    videoLoaded = false;
                    pictureLoaded = false;
                    pictureTexture = null;
                    if (scene) {
                        scene.remove(meshLeft);
                        scene.remove(meshRight);
                        meshLeft = null;
                        meshRight = null;
                    }
                    video.play();
                }
            }

            // Start the XR application.
            initXR();

        })();
    </script>
</body>

</html>